#!/usr/bin/env python

"""sshtunnel: a script for managing SSH tunnels.

Usage:
  sshtunnel [--debug] tunnels
  sshtunnel [--debug] start <name>
  sshtunnel [--debug] [list]
  sshtunnel [--debug] running
  sshtunnel [--debug] restart
  sshtunnel [--debug] stop <name>
  sshtunnel --version
  sshtunnel (-h | --help)

Options:
  -h --help       Show this help.
  --version       Show version.
  --debug         Enable debugging messages.

"""

__title__ = 'SSHTunnel'
__author__ = 'Norman Walsh'
__copyright__ = 'Copyright © 2018, Norman Walsh'
__license__ = 'MIT'
__version__ = '1.1.0'
__uri__ = 'https://github.com/ndw/sshtunnel'

import fcntl
import logging
import json
import psutil
import re
import os
import subprocess
import sys
import time
from datetime import datetime
from docopt import docopt

CONFIGFILE = ".sshtunnels"
PIDFILE = "/tmp/.sshtunnels-pids"
LOCKFILE = "/tmp/.sshtunnels-pids.lock"

class Tunnels:
    """The Tunnels object manages a set of SSH tunnels."""

    def __init__(self,args):
        """Initilize the object"""
        self.tunnels = {}
        self._loadconfig()
        self.lock = None
        self.pids = []
        self.stopped = []
        self.debug = args['--debug']

    def _loadconfig(self):
        """Load the tunnel configuration file from $HOME."""
        home = os.path.expanduser("~")
        cfgfile = home + "/" + CONFIGFILE
        if os.path.isfile(cfgfile):
            data = open(cfgfile).read()
            self.tunnels = json.loads(data)

    def list(self, args):
        """List the tunnels in the configuration file by name."""
        self._load_pids()
        pidmap = {}
        for info in self.pids:
            pidmap[info['name']] = True

        regex = None
        if args['<name>'] is not None:
            regex = ""
            for part in args['<name>']:
                regex = regex + part + ".*"
            regex = re.compile(regex, flags=re.IGNORECASE)

        total = 0
        count = 0
        for tunnel in self.tunnels['tunnels']:
            running = ""
            if tunnel['name'] in pidmap:
                running = "*"

            total += 1
            if regex is None:
                print(tunnel['name'],running)
                count += 1
            else:
                if re.match(regex, tunnel['name']):
                    print(tunnel['name'],running)
                    count += 1

        if count > 1 and count != total:
            print("{} of {} tunnel names match".format(count, total))

    def start(self, args):
        """Start a tunnel."""
        if len(args['<name>']) == 0:
            raise RuntimeError("You must specify a tunnel name")
        regex = ""
        for part in args['<name>']:
            regex = regex + part + ".*"
        regex = re.compile(regex, flags=re.IGNORECASE)
        matches = []
        for tunnel in self.tunnels['tunnels']:
            if re.match(regex, tunnel['name']):
                matches.append(tunnel)

        if len(matches) == 0:
            raise RuntimeError("No tunnel names match: " + " ".join(args['<name>']))

        if len(matches) > 1:
            raise RuntimeError("Multiple tunnel names match: " + " ".join(args['<name>']))

        tunnel = matches[0]

        started = []
        for params in tunnel['params']:
            self._start_tunnel(tunnel, params)

    def _start_tunnel(self, tunnel, params):
        privkey = ""
        if 'privkey' in tunnel:
            if tunnel['privkey'] != '':
                privkey = "-i {} ".format(tunnel['privkey'])

        command = "/usr/bin/ssh {}{}@{} -L {}:{}:{} -N".format(
            privkey,
            tunnel['login'], tunnel['host'],
            params['port1'], params['host'], params['port2'])

        process = subprocess.Popen(command.split(), close_fds=True)

        print("Starting {} ({})".format(tunnel['name'], process.pid))

        self._add_pid(process.pid, tunnel, params)

    def restart(self, args):
        """Restart any stopped tunnels."""
        self._load_pids()
        for info in self.stopped:
            self._start_tunnel(info['tunnel'], info['params'])

    def stop(self, args):
        """Stop a tunnel."""
        if len(args['<name>']) == 0:
            raise RuntimeError("You must specify a tunnel name")
        regex = ""
        for part in args['<name>']:
            regex = regex + part + ".*"
        regex = re.compile(regex, flags=re.IGNORECASE)

        self._get_lock()
        self._get_pids()
        self._release_lock()

        for info in self.pids:
            if re.match(regex, info['name']):
                proc = psutil.Process(info['pid'])
                proc.terminate()
                print("Terminating {} ({})".format(info['name'], info['pid']))

    def _load_pids(self):
        self._get_lock()
        self._get_pids()
        self._check_pids()
        self._save_pids()
        self._release_lock()

    def running(self):
        """Determine which tunnels are running; update the PID cache."""
        self._load_pids()

        # The PIDFILE data structure is a bit of a mess. Let's do a little
        # work to make the print out prettier
        names = []
        for info in self.pids:
            names.append(info['name'])
        names = set(names)

        for name in sorted(names):
            first = True

            for info in self.pids:
                if info['name'] == name:
                    if first:
                        print("{}:".format(name))
                        first = False

                    proc = psutil.Process(info['pid'])
                    today = datetime.fromtimestamp(
                        time.time()).strftime("%Y-%m-%d")
                    sdate = datetime.fromtimestamp(
                        proc.create_time()).strftime("%Y-%m-%d")
                    stime = datetime.fromtimestamp(
                        proc.create_time()).strftime("%H:%M:%S")
                    started = stime
                    if sdate != today:
                        started = sdate + " " + stime
                    print("\t{}:{} → {}:{} since {} (pid: {})".format(
                        info['params']['host'], info['params']['port1'],
                        info['tunnel']['host'], info['params']['port2'],
                        started, info['pid']))

    def _get_pids(self):
        """Load the PID cache file."""
        if os.path.isfile(PIDFILE):
            pids = open(PIDFILE).read()
            self.pids = json.loads(pids)

    def _save_pids(self):
        """Store the PID cache file."""
        with open(PIDFILE, 'w') as outfile:
            json.dump(self.pids, outfile)

    def _check_pids(self):
        """Check to see if the PIDs in the cache appear to be running."""
        pidmap = {}
        for info in self.pids:
            pidmap[info['pid']] = "?"

        for proc in psutil.process_iter(attrs=['pid', 'name', 'username']):
            if proc.info['pid'] in pidmap and proc.info['name'] == 'ssh':
                pidmap[proc.info['pid']] = "running"

        pids = []
        for info in self.pids:
            if pidmap[info['pid']] == 'running':
                pids.append(info)
                if self.debug:
                    print("Running {} ({})".format(info['name'], info['pid']))
            else:
                self.stopped.append(info)
                if self.debug:
                    print("Missing {} ({})".format(info['name'], info['pid']))

        self.pids = pids

    def _add_pid(self, pid, tunnel, params):
        """Add PID for the newly started tunnels to the cache."""
        self._get_lock()
        self._get_pids()
        self._check_pids()

        info = {
            "pid": pid,
            "name": tunnel['name'],
            "tunnel": tunnel,
            "params": params
            }

        self.pids.append(info)

        self._save_pids()

        self._release_lock()

    # I'm not confident these are reliable or cross-platform.
    # Credit: http://tilde.town/~cristo/file-locking-in-python.html
    def _get_lock(self):
        """Obtain a lock for writing to the PID cache."""
        self.lock = open(LOCKFILE, 'w+')
        while True:
            try:
                fcntl.flock(self.lock, fcntl.LOCK_EX | fcntl.LOCK_NB)
                break
            except IOError as e:
                if e.errno != errno.EAGAIN:
                    raise
                else:
                    time.sleep(0.1)


    def _release_lock(self):
        """Release the lock for writing to the PID cache."""
        fcntl.flock(self.lock, fcntl.LOCK_UN)
        self.lock.close()
        self.lock = None

def main():
    args = docopt(__doc__, version="sshtunnel " + __version__)

    if args['--version']:
        print("{} v{}".format(__title__, __version__))
        print(__copyright__)
        print(__uri__)
        if args['command'] is None:
            sys.exit(0)

    command = None
    for key in ['tunnels', 'start', 'list', 'running', 'restart', 'stop']:
        if args[key]:
            command = key

    if command is None:
        args['list'] = True

    tunnels = Tunnels(args)

    try:
        if args['tunnels']:
            tunnels.list(args)
        elif args['start']:
            tunnels.start(args)
        elif args['restart']:
            tunnels.restart(args)
        elif args['stop']:
            tunnels.stop(args)
        elif args['list'] or args['running']:
            tunnels.running()
    except RuntimeError as e:
        print("Error: " + str(e))
        sys.exit(1)

if __name__ == '__main__':
    main()

